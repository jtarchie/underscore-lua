{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Underscore-lua","tagline":"Underscore is a utility-belt library for Lua ","body":"*NOTE*: This is a 1-to-1 port of the orignal [Underscore](http://underscorejs.org/) for Javscript. Lua does not have the same concept of run-time loop, so anything functionality that relied on setTimeout has been removed.\r\n\r\n# Introduction\r\n\r\n[underscore-lua](https://github.com/jtarchie/underscore-lua) is a utility-belt library for Lua that provides a lot of the functional programming support that you would expect in or Ruby's Enumerable.\r\n\r\nThe project is hosted on [GitHub](https://github.com/jtarchie/underscore-lua). You can report bugs and discuss features on the [issues page](https://github.com/jtarchie/underscore-lua/issues), or send tweets to @jtarchie.\r\n\r\n# Table of Contents\r\n\r\n* [Collection](#collection-functions-arrays-or-objects)\r\n* [Arrays](#arrays)\r\n* [Objects](#objects)\r\n* [String](#string)\r\n* [Functions](#functions)\r\n* [Utility](#utility)\r\n* [Chaining](#chaining)\r\n* [Changelog](#changelog)\r\n\r\n# Collection functions (Arrays or Objects)\r\n\r\n## each\r\n\r\n`_.each(list, iterator)`\r\n    \r\nIterates over a list of elements, yielding each in turn to an iterator function. Each invocation of iterator is called with three arguments: (element, index, list). If list is a Lua object, iterator's arguments will be (value, key, list).\r\n\r\n```lua\r\n_.each({1, 2, 3}, print)\r\n=> print each number in turn...\r\n_.each({one=1, two=2, three=3}, function(num, key) print(num) end)\r\n=> print each number in turn...\r\n```\r\n\r\n## map\r\n\r\n`_.map(list, iterator)` Alias: collect\r\n\r\nProduces a new array of values by mapping each value in list through a transformation function (iterator). If list is a Lua object, iterator's arguments will be (value, key, list).\r\n\r\n```lua\r\n_.map({1, 2, 3}, function(num) return num * 3 end)\r\n=> {3, 6, 9}\r\n_.map({one=1, two=2, three=3}, function(num, key) return num * 3 end)\r\n=> {3, 6, 9}\r\n```\r\n\r\n## reduce\r\n\r\n`_.reduce(list, iterator, memo)` Aliases: inject, foldl \r\n\r\nAlso known as inject and foldl, reduce boils down a list of values into a single value. Memo is the initial state of the reduction, and each successive step of it should be returned by iterator. The iterator is passed four arguments: the memo, then the value and index (or key) of the iteration, and finally a reference to the entire list.\r\n\r\n```lua\r\nlocal sum = _.reduce({1, 2, 3}, function(memo, num) return memo + num end, 0)\r\n=> 6\r\n```\r\n\r\n## reduceRight\r\n\r\n`_.reduceRight(list, iterator, memo)` Alias: foldr \r\n\r\nThe right-associative version of reduce. Foldr is not as useful in Lua as it would be in a language with lazy evaluation.\r\n\r\n```lua\r\nlocal list = {{0, 1}, {2, 3}, {4, 5}}\r\nlocal flat = _.reduceRight(list, function(a, b) return _.concat(a, b) end, {})\r\n=> {4, 5, 2, 3, 0, 1}\r\n```\r\n\r\n## find\r\n\r\n`_.find(list, iterator)` Alias: detect\r\n\r\nLooks through each value in the list, returning the first one that passes a truth test (iterator). The function returns as soon as it finds an acceptable element, and doesn't traverse the entire list.\r\n\r\n```lua\r\nlocal even = _.find({1, 2, 3, 4, 5, 6}, function(num) return num % 2 == 0 end)\r\n=> 2\r\n```\r\n\r\n## filter\r\n\r\n`_.filter(list, iterator)` Alias: select\r\n\r\nLooks through each value in the list, returning an array of all the values that pass a truth test (iterator). Delegates to the native filter method, if it exists.\r\n\r\n```lua\r\nlocal evens = _.filter({1, 2, 3, 4, 5, 6}, function(num) return num % 2 == 0 end)\r\n=> {2, 4, 6}\r\n```\r\n\r\n## where\r\n\r\n`_.where(list, properties)`\r\n\r\nLooks through each value in the list, returning an array of all the values that contain all of the key-value pairs listed in properties.\r\n\r\n```lua\r\n_.where(listOfPlays, {author=\"Shakespeare\", year=1611})\r\n=> {{title=\"Cymbeline\", author=\"Shakespeare\", year=1611},\r\n    {title=\"The Tempest\", author=\"Shakespeare\", year=1611}}\r\n```\r\n\r\n## reject\r\n\r\n`_.reject(list, iterator)`\r\n\r\nReturns the values in list without the elements that the truth test (iterator) passes. The opposite of filter.\r\n\r\n```lua\r\nlocal odds = _.reject({1, 2, 3, 4, 5, 6}, function(num) return num % 2 == 0 end)\r\n=> {1, 3, 5}\r\n```\r\n\r\n## all\r\n\r\n`_.all(list, iterator)` Alias: every \r\n\r\nReturns true if all of the values in the list pass the iterator truth test.\r\n\r\n```lua\r\n_.all({true, 1, nil, 'yes'}, _.identity)\r\n=> false\r\n```\r\n\r\n## contains\r\n\r\n`_.contains(list, value)` Alias: include \r\n\r\nReturns true if the value is present in the list. Uses indexOf internally, if list is an Array.\r\n\r\n```lua\r\n_.contains({1, 2, 3}, 3)\r\n=> true\r\n```\r\n\r\n## invoke\r\n\r\n`_.invoke(list, methodName, [*arguments])` \r\n\r\nCalls the method named by methodName on each value in the list. Any extra arguments passed to invoke will be forwarded on to the method invocation.\r\n\r\n```lua\r\nlocal dog = {says=function() return \"woof\" end}\r\nlocal cat = {says=function() return \"meow\" end}\r\nlocal cow = {says=function() return \"moo\" end}\r\n_.invoke({dog, cat, cow}, 'says')\r\n=> {'woof', 'meow', 'moo'}\r\n```\r\n\r\n## pluck\r\n\r\n`_.pluck(list, propertyName)`\r\n\r\nA convenient version of what is perhaps the most common use-case for map: extracting a list of property values.\r\n\r\n```lua\r\nlocal stooges = {{name='moe', age=40}, {name='larry', age=50}, {name='curly', age=60}}\r\n_.pluck(stooges, 'name')\r\n=> {\"moe\", \"larry\", \"curly\"}\r\n```\r\n\r\n## max\r\n\r\n`_.max(list, [iterator])`\r\n\r\nReturns the maximum value in list. If iterator is passed, it will be used on each value to generate the criterion by which the value is ranked.\r\n\r\n```lua\r\nlocal stooges = {{name='moe', age=40}, {name='larry', age=50}, {name='curly', age=60}}\r\n_.max(stooges, function(stooge) return stooge.age end)\r\n=> {name='curly', age=60}\r\n```\r\n\r\n## min\r\n\r\n`_.min(list, [iterator])`\r\n\r\nReturns the minimum value in list. If iterator is passed, it will be used on each value to generate the criterion by which the value is ranked.\r\n\r\n```lua\r\nlocal numbers = {10, 5, 100, 2, 1000}\r\n_.min(numbers)\r\n=> 2\r\n```\r\n\r\n## sortBy\r\n\r\n`_.sortBy(list, iterator)`\r\n\r\nReturns a sorted copy of list, ranked in ascending order by the results of running each value through iterator. Iterator may also be the string name of the property to sort by (eg. length).\r\n\r\n```lua\r\n_.sortBy({1, 2, 3, 4, 5, 6}, function(num) return math.sin(num) end)\r\n=> {5, 4, 6, 3, 1, 2}\r\n```\r\n\r\n## groupBy\r\n\r\n`_.groupBy(list, iterator)`\r\n\r\nSplits a collection into sets, grouped by the result of running each value through iterator. If iterator is a string instead of a function, groups by the property named by iterator on each of the values.\r\n\r\n```lua\r\n_.groupBy({1.3, 2.1, 2.4}, function(num) return math.floor(num) end)\r\n=> {1={1.3}, 2={2.1, 2.4}\r\n```\r\n\r\n## countBy\r\n\r\n`_.countBy(list, iterator)`\r\n\r\nSorts a list into groups and returns a count for the number of objects in each group. Similar to groupBy, but instead of returning a list of values, returns a count for the number of values in that group.\r\n\r\n```lua\r\n_.countBy({1, 2, 3, 4, 5}, function(num) \r\n  if num % 2 == 0 then\r\n    return 'even'\r\n  else\r\n    return 'odd'\r\n  end\r\nend)\r\n=> {odd=3, even=2}\r\n```\r\n\r\n## shuffle\r\n\r\n`_.shuffle(list)`\r\n\r\nReturns a shuffled copy of the list, using a version of the Fisher-Yates shuffle.\r\n\r\n```lua\r\n_.shuffle({1, 2, 3, 4, 5, 6})\r\n=> {4, 1, 6, 3, 5, 2}\r\n```\r\n\r\n\r\n## toArray\r\n\r\n`_.toArray(list)`\r\n\r\nConverts the list (anything that can be iterated over), into a real Array. Useful for transmuting the arguments object.\r\n\r\n```lua\r\n_.toArray(1, 2, 3, 4)\r\n=> {2, 3, 4}\r\n```\r\n\r\n\r\n## size\r\n\r\n`_.size(list)`\r\n\r\nReturn the number of values in the list.\r\n\r\n```lua\r\n_.size({one=1, two=2, three=3})\r\n=> 3\r\n```\r\n\r\n#Arrays\r\n\r\n## first\r\n\r\n`_.first(array, [n])` Alias: head, take \r\n\r\nReturns the first element of an array. Passing n will return the first n elements of the array.\r\n\r\n```lua\r\n_.first({5, 4, 3, 2, 1})\r\n=> 5\r\n```\r\n\r\n## initial\r\n\r\n`_.initial(array, [n])`\r\n\r\nReturns everything but the last entry of the array. Especially useful on variable arguments object. Pass n to exclude the last n elements from the result.\r\n\r\n```lua\r\n_.initial({5, 4, 3, 2, 1})\r\n=> {5, 4, 3, 2}\r\n```\r\n\r\n## last\r\n  \r\n`_.last(array, [n])`\r\n\r\nReturns the last element of an array. Passing n will return the last n elements of the array.\r\n\r\n```lua\r\n_.last({5, 4, 3, 2, 1})\r\n=> 1\r\n```\r\n\r\n## rest\r\n\r\n`_.rest(array, [index])` Alias: tail, drop \r\n\r\nReturns the rest of the elements in an array. Pass an index to return the values of the array from that index onward.\r\n\r\n```lua\r\n_.rest({5, 4, 3, 2, 1})\r\n=> {4, 3, 2, 1}\r\n```\r\n\r\n## compact\r\n  \r\n`_.compact(array)`\r\n\r\nReturns a copy of the array with all falsy values removed. In Lua, false is the only falsy value.\r\n\r\n```lua\r\n_.compact({0, 1, false, 2, '', 3})\r\n=> {0, 1, 2, '', 3}\r\n```\r\n\r\n## flatten\r\n  \r\n`_.flatten(array, [shallow])`\r\n\r\nFlattens a nested array (the nesting can be to any depth). If you pass shallow, the array will only be flattened a single level.\r\n\r\n```lua\r\n_.flatten({1, {2}, {3, {{4}}}})\r\n=> {1, 2, 3, 4}\r\n_.flatten({1, {2}, {3, {{4}}}}, true)\r\n=> {1, 2, 3, {{4}}}\r\n```\r\n\r\n## without\r\n\r\n`_.without(array, [*values])`\r\n\r\nReturns a copy of the array with all instances of the values removed.\r\n\r\n```lua\r\n_.without({1, 2, 1, 0, 3, 1, 4}, 0, 1)\r\n=> {2, 3, 4}\r\n```\r\n\r\n## union\r\n  \r\n`_.union(*arrays)`\r\n\r\nComputes the union of the passed-in arrays: the list of unique items, in order, that are present in one or more of the arrays.\r\n\r\n```lua\r\n_.union({1, 2, 3}, {101, 2, 1, 10}, {2, 1})\r\n=> {1, 2, 3, 101, 10}\r\n```\r\n\r\n## intersection\r\n\r\n`_.intersection(*arrays)`\r\n\r\nComputes the list of values that are the intersection of all the arrays. Each value in the result is present in each of the arrays.\r\n\r\n```lua\r\n_.intersection({1, 2, 3}, {101, 2, 1, 10}, {2, 1})\r\n=> {1, 2}\r\n```\r\n\r\n## difference\r\n\r\n`_.difference(array, *others)`\r\n\r\nSimilar to without, but returns the values from array that are not present in the other arrays.\r\n\r\n```lua\r\n_.difference({1, 2, 3, 4, 5}, {5, 2, 10})\r\n=> {1, 3, 4}\r\n```\r\n\r\n## uniq\r\n\r\n`_.uniq(array, [isSorted], [iterator])` Alias: unique\r\n\r\nProduces a duplicate-free version of the array, using === to test object equality. If you know in advance that the array is sorted, passing true for isSorted will run a much faster algorithm. If you want to compute unique items based on a transformation, pass an iterator function.\r\n\r\n```lua\r\n_.uniq({1, 2, 1, 3, 1, 4})\r\n=> {1, 2, 3, 4}\r\n```\r\n\r\n## zip\r\n\r\n`_.zip(*arrays)`\r\n\r\nMerges together the values of each of the arrays with the values at the corresponding position. Useful when you have separate data sources that are coordinated through matching array indexes. If you're working with a matrix of nested arrays, zip.apply can transpose the matrix in a similar fashion.\r\n\r\n```lua\r\n_.zip({'moe', 'larry', 'curly'}, {30, 40, 50}, {true, false, false})\r\n=> {{\"moe\", 30, true}, {\"larry\", 40, false}, {\"curly\", 50, false}}\r\n```\r\n\r\n## object\r\n\r\n`_.object(list, [values])`\r\n\r\nConverts arrays into objects. Pass either a single list of (key, value) pairs, or a list of keys, and a list of values.\r\n\r\n```lua\r\n_.object({'moe', 'larry', 'curly'}, {30, 40, 50})\r\n=> {moe=30, larry=40, curly=50}\r\n_.object({{'moe', 30}, {'larry', 40}, {'curly', 50}})\r\n=> {moe=30, larry=40, curly=50}\r\n```\r\n\r\n## indexOf\r\n\r\n`_.indexOf(array, value, [isSorted])`\r\n\r\nReturns the index at which value can be found in the array, or 0 if value is not present in the array. Uses the native indexOf function unless it's missing. If you're working with a large array, and you know that the array is already sorted, pass true for isSorted to use a faster binary search ... or, pass a number as the third argument in order to look for the first matching value in the array after the given index.\r\n\r\n```lua\r\n_.indexOf({1, 2, 3}, 2)\r\n=> 1\r\n```\r\n\r\n## lastIndexOf\r\n\r\n`_.lastIndexOf(array, value, [fromIndex])`\r\n\r\nReturns the index of the last occurrence of value in the array, or 0 if value is not present. Uses the native lastIndexOf function if possible. Pass fromIndex to start your search at a given index.\r\n\r\n```lua\r\n_.lastIndexOf({1, 2, 3, 1, 2, 3}, 2)\r\n=> 4\r\n```\r\n\r\n## range\r\n\r\n`_.range([start], stop, [step])`\r\n\r\nA function to create flexibly-numbered lists of integers, handy for each and map loops. start, if omitted, defaults to 0; step defaults to 1. Returns a list of integers from start to stop, incremented (or decremented) by step, exclusive.\r\n\r\n```lua\r\n_.range(10)\r\n=> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\r\n_.range(1, 11)\r\n=> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\r\n_.range(0, 30, 5)\r\n=> {0, 5, 10, 15, 20, 25}\r\n_.range(0, -10, -1)\r\n=> {0, -1, -2, -3, -4, -5, -6, -7, -8, -9}\r\n_.range(0)\r\n=> {} \r\n```\r\n\r\n## pop\r\n\r\n`_.pop(array)`\r\n\r\nRemoves the last element from an array and returns that value.\r\n\r\n```lua\r\n_.pop({1,2,3,4})\r\n=> 4\r\n```\r\n\r\n## push\r\n\r\n`_.push(array, [elements])`\r\n\r\nAdds the list of elements on to the end of an array.\r\n\r\n```lua\r\nlocal array = {1,2,3}\r\n_.push(array, 4,5,6)\r\n=> {1,2,3,4,5,6}\r\n=> array == {1,2,3,4,5,6}\r\n```\r\n\r\n## shift\r\n\r\n`_.shift(array)`\r\n\r\nRemoves the last element from an array and returns that value.\r\n\r\n```lua\r\n_.shift({1,2,3,4})\r\n=> 1\r\n```\r\n\r\n## unshift\r\n\r\n`_.unshift(array, [elements])`\r\n\r\nAdds the list of elements on to the end of an array.\r\n\r\n\r\n```lua\r\nlocal array = {1,2,3}\r\n_.unshift(array, 4,5,6)\r\n=> {4,5,6,1,2,3}\r\n=> array == {4,5,6,1,2,3}\r\n```\r\n\r\n## slice\r\n\r\n`_.slice(array, begin, [end])`\r\n\r\nReturns a portion of the array that starts from begin and returning all the elemtns to the end of the array. If end is provided then it provideds the elements to that position.\r\n\r\n```lua\r\n_.slice({1,2,3,4,5,6,7,8}, 4)\r\n=> {4,5,6,7,8}\r\n_.slice({1,2,3,4,5,6,7,8}, 4, 6)\r\n=> {4,5,6}\r\n```\r\n\r\n## sort\r\n\r\n`_.sort(array, [compareFunction])`\r\n\r\nSorts the elements in the array based on the `tostring` value of the element. For numerical values, this puts \"80\" before \"9\" in their lexical form.\r\n\r\nWith the compareFunction, the elements are sorted based on the returned value. This relies on Lua's underlying `table.sort` so the comparison relies the value being compared as less than or grater than.\r\n\r\n```lua\r\n_.sort({\"how\",\"are\",\"you\",\"today\"})\r\n=> {\"are\",\"how\",\"today\",\"you\"}\r\n_.sort({1,5,10,90})\r\n=> {1,10,5,90}\r\n```\r\n\r\n## concat\r\n\r\n`_.concat(value1, value2, ..., arrayn)`\r\n\r\nCreates a new array by concatenating the values passed in. It does not alter the original versions of the values passed in.\r\n\r\n```lua\r\n_.concat(1,2,3,4,5,6)\r\n=> {1,2,3,4,5,6}\r\n_.concat({1,2,3},{4,5,6})\r\n=> {1,2,3,4,5,6}\r\n```\r\n\r\n## join\r\n\r\n`_.join(array, [separator])`\r\n\r\nJoins the elements of an array into a string. By default the separator is a blank string. If a separator is passed then it will be used as the string that separates the elements in the string.\r\n\r\n```lua\r\n_.join({1,2,3,4,5})\r\n=> \"12345\"\r\n_.join({\"Hello\", \"world\"}, \", \")\r\n=> \"Hello, world\"\r\n```\r\n\r\n## splice\r\n\r\nNot yet Implemented\r\n\r\n#Functions\r\n\r\n## memoize\r\n\r\n`_.memoize(function, [hashFunction])`\r\n\r\nMemoizes a given function by caching the computed result. Useful for speeding up slow-running computations. If passed an optional hashFunction, it will be used to compute the hash key for storing the result, based on the arguments to the original function. The default hashFunction just uses the first argument to the memoized function as the key.\r\n\r\n```lua\r\nlocal fibonacci = _.memoize(function(n)\r\n  if n < 2 then\r\n    return n\r\n  else \r\n    return fibonacci(n - 1) + fibonacci(n - 2)\r\n  end\r\nend)\r\n```\r\n\r\n## once\r\n\r\n`_.once(function)`\r\n\r\nCreates a version of the function that can only be called one time. Repeated calls to the modified function will have no effect, returning the value from the original call. Useful for initialization functions, instead of having to set a boolean flag and then check it later.\r\n\r\n```lua\r\nlocal initialize = _.once(createApplication)\r\ninitialize()\r\ninitialize()\r\n```\r\n\r\n## after\r\n\r\n`_.after(count, function)`\r\n\r\nCreates a version of the function that will only be run after first being called count times. Useful for grouping asynchronous responses, where you want to be sure that all the async calls have finished, before proceeding.\r\n\r\n```lua\r\nlocal renderNotes = _.after(_.size(notes), render)\r\n_.each(notes, function(note)\r\n  note.asyncSave({success: renderNotes})\r\nend)\r\n```\r\n\r\n## wrap\r\n\r\n`_.wrap(function, wrapper)`\r\n\r\nWraps the first function inside of the wrapper function, passing it as the first argument. This allows the wrapper to execute code before and after the function runs, adjust the arguments, and execute it conditionally.\r\n\r\n```lua\r\nlocal hello = function(name) return \"hello: \" + name end\r\nhello = _.wrap(hello, function(func)\r\n  return \"before, \" + func(\"moe\") + \", after\"\r\nend)\r\nhello()\r\n=> 'before, hello: moe, after'\r\n```\r\n\r\n## compose\r\n  \r\n`_.compose(*functions)`\r\n\r\nReturns the composition of a list of functions, where each function consumes the return value of the function that follows. In math terms, composing the functions f(), g(), and h() produces f(g(h())).\r\n\r\n```lua\r\nlocal greet    = function(name) return \"hi: \" + name end\r\nlocal exclaim  = function(statement) return statement + \"!\" end\r\nlocal welcome = _.compose(exclaim, greet)\r\nwelcome('moe')\r\n=> 'hi: moe!'\r\n```\r\n\r\n#Objects\r\n\r\n## keys\r\n\r\n`_.keys(object)`\r\n\r\nRetrieve all the names of the object's properties. The order of the keys is not guaranteed to be consistent.\r\n\r\n```lua\r\n_.keys({one=1, two=2, three=3})\r\n=> {\"one\", \"two\", \"three\"}\r\n```\r\n## values\r\n\r\n`_.values(object)`\r\n\r\nReturn all of the values of the object's properties. The order of the values is not guaranteed to be consistent.\r\n\r\n```lua\r\n_.values({one=1, two=2, three=3})\r\n=> {1, 2, 3}\r\n```\r\n\r\n## pairs\r\n\r\n`_.pairs(object)`\r\n\r\nConvert an object into a list of [key, value] pairs.\r\n\r\n```lua\r\n_.pairs({one=1, two=2, three=3})\r\n=> [[\"one\", 1], [\"two\", 2], [\"three\", 3]]\r\n```\r\n\r\n## invert\r\n\r\n`_.invert(object)`\r\n\r\nReturns a copy of the object where the keys have become the values and the values the keys. For this to work, all of your object's values should be unique and string serializable.\r\n\r\n```lua\r\n_.invert({Moe=\"Moses\", Larry=\"Louis\", Curly=\"Jerome\"})\r\n=> {Moses=\"Moe\", Louis=\"Larry\", Jerome=\"Curly\"}\r\n```\r\n\r\n## functions\r\n\r\n`_.functions(object)` Alias: methods\r\n\r\nReturns a sorted list of the names of every method in an object â€” that is to say, the name of every function property of the object.\r\n\r\n```lua\r\n_.functions(_)\r\n=> {\"all\", \"any\", \"bind\", \"bindAll\", \"clone\", \"compact\", \"compose\" ... }\r\n```\r\n\r\n## extend\r\n\r\n`_.extend(destination, *sources)`\r\n\r\nCopy all of the properties in the source objects over to the destination object, and return the destination object. It's in-order, so the last source will override properties of the same name in previous arguments.\r\n\r\n```lua\r\n_.extend({name='moe'}, {age=50})\r\n=> {name='moe', age=50}\r\n```\r\n\r\n## pick\r\n\r\n`_.pick(object, *keys)`\r\n\r\nReturn a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys).\r\n\r\n```lua\r\n_.pick({name='moe', age=50, userid='moe1'}, 'name', 'age')\r\n=> {name='moe', age=50}\r\n```\r\n\r\n## omit\r\n\r\n`_.omit(object, *keys)`\r\n\r\nReturn a copy of the object, filtered to omit the blacklisted keys (or array of keys).\r\n\r\n```lua\r\n_.omit({name='moe', age=50, userid='moe1'}, 'userid')\r\n=> {name='moe', age=50}\r\n```\r\n\r\n## defaults\r\n\r\n`_.defaults(object, *defaults)`\r\n\r\nFill in null and undefined properties in object with values from the defaults objects, and return the object. As soon as the property is filled, further defaults will have no effect.\r\n\r\n```lua\r\nlocal iceCream = {flavor=\"chocolate\"}\r\n_.defaults(iceCream, {flavor=\"vanilla\", sprinkles=\"lots\"})\r\n=> {flavor=\"chocolate\", sprinkles=\"lots\"}\r\n```\r\n\r\n## clone\r\n\r\n`_.clone(object)`\r\n\r\nCreate a shallow-copied clone of the object. Any nested objects or arrays will be copied by reference, not duplicated.\r\n\r\n```lua\r\n_.clone({name='moe'})\r\n=> {name='moe'}\r\n```\r\n\r\n## tap\r\n\r\n`_.tap(object, interceptor)`\r\n\r\nInvokes interceptor with the object, and then returns object. The primary purpose of this method is to \"tap into\" a method chain, in order to perform operations on intermediate results within the chain.\r\n\r\n```lua\r\n_.chain([1,2,3,200])\r\n  :filter(function(num) return num % 2 == 0 end)\r\n  :tap(print)\r\n  --  {2, 200}\r\n  :map(function(num) return num * num end)\r\n  :value()\r\n=> {4, 40000}\r\n```\r\n\r\n## has\r\n\r\n`_.has(object, key)`\r\n\r\nDoes the object contain the given key? Identical to object.hasOwnProperty(key), but uses a safe reference to the hasOwnProperty function, in case it's been overridden accidentally.\r\n\r\n```lua\r\n_.has({a=1, b=2, c=3}, \"b\")\r\n=> true\r\n```\r\n\r\n## isEqual\r\n\r\nNot yet implemented\r\n\r\n## isEmpty\r\n\r\n`_.isEmpty(object)`\r\n\r\nReturns true if object contains no values.\r\n\r\n```lua\r\n_.isEmpty({1, 2, 3})\r\n=> false\r\n_.isEmpty({})\r\n=> true\r\n```\r\n\r\n## isArray\r\n\r\n`_.isArray(object)`\r\n\r\nReturns true if object is an Array.\r\n\r\n```lua\r\n_.isArray({1,2,3})\r\n=> true\r\n```\r\n\r\n## isObject\r\n\r\n`_.isObject(value)`\r\n\r\nReturns true if value is an Object. Note that JavaScript arrays and functions are objects, while (normal) strings and numbers are not.\r\n\r\n```lua\r\n_.isObject({})\r\n=> true\r\n_.isObject(1)\r\n=> false\r\n```\r\n\r\n## isFunction\r\n\r\n`_.isFunction(object)`\r\n\r\nReturns true if object is a Function.\r\n\r\n```lua\r\n_.isFunction(print)\r\n=> true\r\n```\r\n\r\n## isString\r\n\r\n`_.isString(object)`\r\n\r\nReturns true if object is a String.\r\n\r\n```lua\r\n_.isString(\"moe\")\r\n=> true\r\n```\r\n\r\n## isNumber\r\n\r\n`_.isNumber(object)`\r\n\r\nReturns true if object is a Number (including NaN).\r\n\r\n```lua\r\n_.isNumber(8.4 * 5)\r\n=> true\r\n```\r\n\r\n## isFinite\r\n\r\n`_.isFinite(object)`\r\n\r\nReturns true if object is a finite Number.\r\n\r\n```lua\r\n_.isFinite(-101)\r\n=> true\r\n_.isFinite(math.huge)\r\n=> false\r\n```\r\n\r\n## isBoolean\r\n\r\n`_.isBoolean(object)`\r\n\r\nReturns true if object is either true or false.\r\n\r\n```lua\r\n_.isBoolean(nil)\r\n=> false\r\n```\r\n\r\n## isNaN\r\n\r\n`_.isNaN(object)`\r\n\r\nReturns true if object is NaN.\r\n\r\n```lua\r\n_.isNaN(0/0)\r\n=> true\r\n_.isNaN(1)\r\n=> false\r\n```\r\n\r\n## isNil\r\n\r\n`_.isNil(object)`\r\n\r\nReturns true if the value of object is nil.\r\n\r\n```lua\r\n_.isNil(nil)\r\n=> true\r\n_.isNil(1)\r\n=> false\r\n```\r\n\r\n#Utility\r\n\r\n## identity\r\n\r\n`_.identity(value)`\r\n\r\nReturns the same value that is used as the argument. In math: f(x) = x\r\n\r\nThis function looks useless, but is used throughout Underscore as a default iterator.\r\n\r\n```lua\r\nlocal moe = {name='moe'}\r\nmoe == _.identity(moe);\r\n=> true\r\n```\r\n\r\n## times\r\n\r\n`_.times(n, iterator)`\r\n\r\nInvokes the given iterator function n times. Each invocation of iterator is called with an index argument.\r\n\r\n```lua\r\n_(3).times(function(n) genie.grantWishNumber(n) end)\r\n```\r\n\r\n## random\r\n\r\n`_.random(min, max)`\r\n\r\nReturns a random integer between min and max, inclusive. If you only pass one argument, it will return a number between 0 and that number.\r\n\r\n```lua\r\n_.random(0, 100)\r\n=> 42\r\n```\r\n\r\n## mixin\r\n\r\n`_.mixin(object)`\r\n\r\nAllows you to extend Underscore with your own utility functions. Pass a hash of {name: function} definitions to have your functions added to the Underscore object, as well as the OOP wrapper.\r\n\r\n```lua\r\n_.mixin({\r\n  capitalize=function(s)\r\n    return s:substr(1,1):upper() .. s:substr(2):lower()\r\n  end\r\n})\r\n_(\"fabio\").capitalize();\r\n=> \"Fabio\"\r\n```\r\n\r\n## uniqueId\r\n\r\n`_.uniqueId([prefix])`\r\n\r\nGenerate a globally-unique id for client-side models or DOM elements that need one. If prefix is passed, the id will be appended to it. Without prefix, returns an integer.\r\n\r\n```lua\r\n_.uniqueId('contact_')\r\n=> 'contact_104'\r\n```\r\n\r\n## escape\r\n\r\n`_.escape(string)`\r\n\r\nEscapes a string for insertion into HTML, replacing &, <, >, \", ', and / characters.\r\n\r\n```lua\r\n_.escape('Curly, Larry & Moe')\r\n=> \"Curly, Larry &amp; Moe\"\r\n```\r\n\r\n## unescape\r\n\r\n`_.unescape(string)`\r\n\r\nUn-escapes a string from HTML to the proper characters  &, <, >, \", ', and /.\r\n\r\n```lua\r\n_.unescape('Curly, Larry &amp Moe')\r\n=> \"Curly, Larry & Moe\"\r\n```\r\n\r\n## result\r\n\r\n`_.result(object, property)`\r\n\r\nIf the value of the named property is a function then invoke it; otherwise, return it.\r\n\r\n```lua\r\nvar object = {cheese='crumpets', stuff=function() return 'nonsense' end}\r\n_.result(object, 'cheese')\r\n=> \"crumpets\"\r\n_.result(object, 'stuff')\r\n=> \"nonsense\"\r\n```\r\n\r\n# String\r\n\r\n## split\r\n\r\n`_.split(value, [separator])`\r\n\r\nSplits a string into an array of strings by separating the string into substrings. If there is no separator is passed, the substring are individual characters.\r\n\r\nWith a separator, the substring is string up to the separator position. The separator can be a [string pattern](http://www.lua.org/manual/5.2/manual.html#6.4.1).\r\n\r\n```lua\r\n_.split(\"John Smith\")\r\n=> {\"J\",\"o\",\"h\",\"n\",\" \",\"S\",\"m\",\"i\",\"t\",\"h\"}\r\n_.split(\"John Smith\", \"%s+\")\r\n=> {\"John\", \"Smith\"}\r\n```\r\n\r\n#Chaining\r\n\r\nYou can use Underscore in either an object-oriented or a functional style, depending on your preference. The following two lines of code are identical ways to double a list of numbers.\r\n\r\n```lua\r\n_.map([1, 2, 3], function(n) return n * 2 end)\r\n_([1, 2, 3]).map(function(n) return n * 2 end)\r\n```\r\n\r\nCalling chain will cause all future method calls to return wrapped objects. When you've finished the computation, use value to retrieve the final value. Here's an example of chaining together a map/flatten/reduce, in order to get the word count of every word in a song.\r\n\r\n```lua\r\nlocal lyrics = {\r\n  {line=1, words=\"I'm a lumberjack and I'm okay\"},\r\n  {line=2, words=\"I sleep all night and I work all day\"},\r\n  {line=3, words=\"He's a lumberjack and he's okay\"},\r\n  {line=4, words=\"He sleeps all night and he works all day\"}\r\n}\r\n\r\n_.chain(lyrics)\r\n  :map(function(line) return _.split(line.words, ' ') end)\r\n  :flatten()\r\n  :reduce(function(counts, word)\r\n    counts[word] = counts[word] or 0\r\n    counts[word] = counts[word] + 1\r\n    return counts\r\n  end, {})\r\n  :value()\r\n\r\n=> {lumberjack=2, all=4, night=2 ... }\r\n```\r\n\r\n## chain\r\n\r\n`_.chain(obj)`\r\n\r\nReturns a wrapped object. Calling methods on this object will continue to return wrapped objects until value is used.\r\n\r\n```lua\r\nlocal stooges = {{name='curly', age=25}, {name='moe', age=21}, {name='larry', age=23}}\r\nlocal youngest = _.chain(stooges)\r\n  :sortBy(function(stooge) return stooge.age end)\r\n  :map(function(stooge) return stooge.name .. ' is ' .. stooge.age end)\r\n  :first()\r\n  :value()\r\n=> \"moe is 21\"\r\n```\r\n\r\n## value\r\n\r\n`_(obj).value()`\r\n\r\nExtracts the value of a wrapped object.\r\n\r\n```lua\r\n_({1, 2, 3}).value();\r\n=> {1, 2, 3}\r\n```\r\n\r\n\r\n#Changelog\r\n"}